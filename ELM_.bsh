import java.awt.Color;
import java.awt.Desktop;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.KeyEventPostProcessor;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.awt.geom.Rectangle2D;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.DecimalFormat;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;

import javax.swing.ActionMap;
import javax.swing.InputMap;

import fiji.util.gui.GenericDialogPlus;
import loci.formats.FormatException;
import loci.formats.ImageReader;
import au.com.bytecode.opencsv.CSVReader;
import bdv.SpimSource;
import bdv.export.ProgressWriterConsole;
import bdv.gui.BigWarpViewerFrame;
import bdv.tools.InitializeViewerState;
import bdv.spimdata.SpimDataMinimal;
import bdv.tools.brightness.RealARGBColorConverterSetup;
import bdv.tools.transformation.TransformedSource;
import bdv.util.AbstractNamedAction;
import bdv.util.KeyProperties;
import bdv.util.AbstractNamedAction.NamedActionAdder;
import bdv.util.KeyProperties.KeyStrokeAdder;
import bdv.viewer.BigWarpViewerPanel;
import bdv.viewer.DisplayMode;
import bdv.viewer.InputActionBindings;
import bdv.viewer.Interpolation;
import bdv.viewer.SourceAndConverter;
import bdv.viewer.animate.AbstractAnimator;
import bdv.viewer.animate.OverlayAnimator;
import bigwarp.BigWarp;
import bigwarp.BigWarpInit;
import bigwarp.BigWarp.BigWarpData;
import bigwarp.loader.ImagePlusLoader;
import ij.IJ;
import ij.ImageJ;
import ij.ImagePlus;
import ij.process.LUT;
import net.imglib2.RealPoint;
import net.imglib2.RealRandomAccess;
import net.imglib2.display.RealLUTARGBColorConverter;
import net.imglib2.type.numeric.ARGBType;
import net.imglib2.type.numeric.integer.UnsignedByteType;

WIDTH  = 1024;
HEIGHT = 1024;

DEFAULT_LANDMARKS = "/groups/saalfeld/public/flytem-eml/lm-em-landmarks.csv";
DEFAULT_IMAGE = "/groups/saalfeld/public/flytem-eml/DPX_Standard2013/JFRC2013.tif";

DPX_LABELS_IMAGE = "/groups/saalfeld/public/vfb/DPX_Standard2013_Mask20131111_labels.tif";
DPX_LABELS_NAMES = "/groups/saalfeld/public/vfb/DPX_Standard2013_Mask20131111.csv";
DPX_LABELS_ID ="DPX_Standard2013_Mask20131111";

VFB_LABELS_IMAGE = "/groups/saalfeld/public/vfb/JFRCtempate2010.mask130819_Original_warp.tif";
VFB_LABELS_NAMES = "/groups/saalfeld/public/vfb/Original_Index.csv";
VFB_LABELS_ID = "VFB";

EXPECTED_IMAGE_DIMS = new int[]{ 1450, 725, 436 };

public static class LabelNameOverlayFetcher
{
    BigWarpViewerPanel panel;
    HashMap labelNames;

    RealPoint mousePoint;
    double[] mouseArray;

    BigWarp bw;
    int index;

    LabelNameOverlayFetcher( BigWarpViewerPanel viewer, HashMap labelNames, BigWarp bw, int index  )
    {
        this.panel = viewer;
        this.labelNames = labelNames;

        this.index = index;
        this.bw = bw;

        mouseArray = new double[ 3 ];
        mousePoint = RealPoint.wrap( mouseArray );
    }

    String getName()
    {
        srcra = bw.getSources().get( index ).getSpimSource().getInterpolatedSource( 0, 0, Interpolation.NEARESTNEIGHBOR ).realRandomAccess();

        panel.getGlobalMouseCoordinates( mousePoint );
        srcra.setPosition( mouseArray );
        String name = labelNames.get( srcra.get().getInteger() );
        if( name != null )
            return name;
        else
            return "< no label >";
    }
}

public class ShowMessageAction extends AbstractNamedAction
{
	long serialVersionUID = 3856613701227807288L;
	BigWarpViewerPanel panel;
    LabelNameOverlayFetcher nameFetcher;

	ShowMessageAction( String name, BigWarpViewerPanel panel,  LabelNameOverlayFetcher nameFetcher )
	{
		super( name );
		this.panel = panel;
		this.nameFetcher = nameFetcher;
	}

    public void actionPerformed( ActionEvent e )
    {
        panel.showMessage( nameFetcher.getName() );
	}
}

void addLabelActions( BigWarpViewerFrame viewer, LabelNameOverlayFetcher animator )
{
    if( animator == null ){ return; }

    config = new Properties();
    keyProperties = new KeyProperties( config );

    inputMap = new InputMap();
    map = keyProperties.adder( inputMap );
    map.put( "DISPLAY LABEL NAME", new String[]{ "L" } );

    actionMap = new ActionMap();
    actionAdder = new NamedActionAdder( actionMap );
    actionAdder.put( new ShowMessageAction( "DISPLAY LABEL NAME", viewer.getViewerPanel(), animator ));

    keybindings = viewer.getKeybindings();

    keybindings.addActionMap( "labels", actionMap );
    keybindings.addInputMap(  "labels", inputMap, new String[]{} );

}

public static HashMap loadCompartmentLabels( String csvPath )
{
    // try loading the csv
    rows = null;
    try
    {
        reader = new CSVReader( new FileReader( csvPath ));
        rows = reader.readAll();
        reader.close();
    } catch ( FileNotFoundException e )
    {
        e.printStackTrace();
    } catch ( IOException e )
    {
        e.printStackTrace();
    }

    if( rows == null )
        return null;

    labelsToName = new HashMap();
    for( String[] row : rows )
    {
        // allow for rows with unexpected content and try to continue if possible
        try
        {
            labelsToName.put( Integer.parseInt( row[ 1 ] ), row [ 2 ] );
        }
        catch( NumberFormatException e ) {}
    }

    if ( labelsToName.isEmpty() )
        return null;

    return labelsToName;
}

LabelNameOverlayFetcher addLabelNameOverlay( BigWarpViewerPanel panel, BigWarp bw, String fnCompartmentLabels, int index )
{
    labels2Names = loadCompartmentLabels( fnCompartmentLabels );
    lnoa = new LabelNameOverlayFetcher( panel, labels2Names, bw, index );
    panel.getDisplay().addHandler( lnoa );
    return lnoa;
}

/**
 * Return true if f has the extension ext,
 * and is an image of size [ nx, ny, nz ] 
 * and is not RGB
 * and is single channel.
 *  
 * @param f
 * @param nx the image width
 * @param ny the image height
 * @param nz the image depth
 * @param ext the file extension
 * @return
 */
boolean isConsistentSize( String f, int nx, int ny, int nz, String ext )
{
    if ( !f.endsWith( ext ) )
        return false;

    try
    {
        reader = new ImageReader();
        reader.setId( f );
        result =
                ( !reader.isRGB() ) && 
                ( reader.getSizeX() == nx ) && 
                ( reader.getSizeY() == ny ) &&
                ( reader.getSizeZ() == nz || reader.getImageCount() == nz ) &&
                ( reader.getSizeC() == 1 );

        reader.close();
        return result;
    } 
    catch ( FormatException e ) {}
    catch ( IOException e ) {}

    return false;
}

void checkInputImages( ImagePlus[] impList )
{
	for( int i = 0; i < impList.length; i++ )
	{
		dims = impList[ i ].getDimensions();
		for( int j = 0; j < 2; j++ )
		{
			if( dims[ j ] != EXPECTED_IMAGE_DIMS[ j ] )
			{
				warning = "WARNING: Expecting images of size " + printArray( EXPECTED_IMAGE_DIMS ) +
					" but image " + impList[ i ].getTitle() + " has size " + printArray( dims );
				IJ.error( warning );
                break;
			}
		}
	}
}

String printArray( int[] in )
{
	out = "( ";
	for( int i = 0; i < in.length; i++ )
	{
		out += in[ i ];
		if( i < in.length - 1 )
			out += ", ";
	}
	out += " )";
	return out;
}

BigWarpData addLabels( BigWarpData data, String fnCompartmentLabels, String compartmentName )
{
    tmp = data.movingSourceIndices;
    newMSI = new int[ tmp.length + 1 ];
    System.arraycopy( tmp, 0, newMSI, 0, tmp.length );
    newMSI[ tmp.length ] = data.sources.size();

    setupId = 20131111;

    labels = IJ.openImage( fnCompartmentLabels );
    spimdat = new ImagePlusLoader( labels ).loadAll( 20131111 )[ 0 ];

    lut = labels.getLuts()[ 0 ];
    rgba = new int[ lut.getMapSize() ];
    lut.getRGBs( rgba );

    converter = new RealLUTARGBColorConverter( labels.getDisplayRangeMin(), labels.getDisplayRangeMax(), rgba );

    s = new SpimSource( spimdat, setupId, compartmentName );

    // Decorate each source with an extra transformation, that can be
    // edited manually in this viewer.UnsignedByteType
    ts = new TransformedSource( s );
    soc = new SourceAndConverter( ts, converter );

    data.sources.add( soc );
    convList = new ArrayList();
    convList.add( converter );
    data.converterSetups.add( new RealARGBColorConverterSetup( setupId, convList ) );

    return new BigWarpData( data.sources, data.seqP, data.seqQ, data.converterSetups, newMSI, data.targetSourceIndices );
}


ImagePlus[] loadImages( String selection )
{
    baseF = new File( selection );
    dir = new File( baseF.getParent() );
    fList = dir.listFiles();
    

    baseImp = IJ.openImage( selection );
    ext = selection.substring( selection.lastIndexOf( '.' ));
    nx = baseImp.getWidth();
    ny = baseImp.getHeight();
    nz = baseImp.getNSlices();

    numImages = 1;
    loadMe = new boolean[ fList.length ];
    for ( int i = 0; i < fList.length; i++ )
    {
        f = fList[ i ];
        // dont process the file that was selected
        if( f.isDirectory() || f.getName().equals( baseF.getName() ))
        {
            continue;
        }

        try
        {
            if ( isConsistentSize( f.getCanonicalPath(), nx, ny, nz, ext ) )
            {
                loadMe[ i ] = true;
                numImages++;
            }
        } catch ( IOException e ) {}

    }

    int k = 0;
    out = new ImagePlus[ numImages ];
    out[ k++ ] = baseImp;
    for ( int i = 0; i < fList.length; i++ )
    {
        if ( loadMe[ i ] )
        {
            try
            {
                out[ k++ ] = IJ.openImage( fList[ i ].getCanonicalPath() );
            } 
            catch ( IOException e ) {}
        }
    }

    return out;
}

gd = new GenericDialogPlus( "BigWarp" );
gd.addFileField( "Landmarks: ", IJ.getDir("plugins") + "elm/lm-em-landmarks.csv" );
gd.addFileField( "Light template: ", DEFAULT_IMAGE );
gd.addCheckbox( "Auto discover", true );
gd.addRadioButtonGroup( "Label", new String[]{"None", "DPX", "VFB"}, 1, 3, "None" );
gd.showDialog();

if (!gd.wasCanceled())
{
    fnLandmarks = gd.getNextString();
    fnMoving = gd.getNextString();
    autoDiscover = gd.getNextBoolean();
    labelOption = gd.getNextRadioButton();

    loadLabels = false;
    fnCompartmentImage = "";
    fnCompartmentNames = "";
    compartmentId = "";

    if( labelOption.equals( "DPX" ))
    {
        loadLabels = true;
        fnCompartmentImage = DPX_LABELS_IMAGE;
        fnCompartmentNames = DPX_LABELS_NAMES;
        compartmentId = DPX_LABELS_ID;
    }
    else if( labelOption.equals( "VFB" ))
    {
        loadLabels = true;
        fnCompartmentImage = VFB_LABELS_IMAGE;
        fnCompartmentNames = VFB_LABELS_NAMES;
        compartmentId = VFB_LABELS_ID;
    }

    // These two lines can remain as they are if elm is cloned into your
    // home directory.  Otherwise, they will need modification. 
    FAFB_XML = IJ.getDir("plugins") + "/elm/catmaid-fafb00-v11-align-tps.xml";

    try
    {
        System.setProperty( "apple.laf.useScreenMenuBar", "false" );

        if ( autoDiscover )
            impList = loadImages( fnMoving );
        else
            impList = new ImagePlus[]{ IJ.openImage( fnMoving ) };

        checkInputImages( impList );

        if ( impList != null && impList.length > 0 && impList[ 0 ] != null )
        {

            data = null;
            if( !fnCompartmentNames.isEmpty() && loadLabels )
            {
                BigWarpData dataRaw = BigWarpInit.createBigWarpDataFromImagePlusXML( impList, FAFB_XML );
                labelSourceIndex = dataRaw.sources.size();
                data = addLabels( dataRaw, fnCompartmentImage, compartmentId );
            }
            else
            {
                data = BigWarpInit.createBigWarpDataFromImagePlusXML( impList, FAFB_XML );
            }


            bw = new BigWarp( data, new File( fnMoving ).getName(), new ProgressWriterConsole() );
			bw.setImageJInstance( IJ.getInstance() );

            if ( !fnLandmarks.isEmpty() )
                bw.getLandmarkPanel().getTableModel().load( new File( fnLandmarks ) );

            LabelNameOverlayFetcher lnoaP;
            LabelNameOverlayFetcher lnoaQ;
            if( !fnCompartmentNames.isEmpty() )
            {
                lnoaP = addLabelNameOverlay( bw.getViewerFrameP().getViewerPanel(), bw, fnCompartmentNames, labelSourceIndex );
                lnoaQ = addLabelNameOverlay( bw.getViewerFrameQ().getViewerPanel(), bw, fnCompartmentNames, labelSourceIndex );

                addLabelActions( bw.getViewerFrameP(), lnoaP );
                addLabelActions( bw.getViewerFrameQ(), lnoaQ );
            }else
            {
                lnoaP = null;
                lnoaQ = null;
            }

            int i = 0;
            // correct viewer transform and contrast
            bw.getViewerFrameQ().getViewerPanel().getVisibilityAndGrouping().setCurrentSource( data.targetSourceIndices[ 0 ] );
            InitializeViewerState.initTransform( bw.getViewerFrameQ().getViewerPanel() );
            InitializeViewerState.initBrightness( 0.001, 0.999, bw.getViewerFrameQ().getViewerPanel(), bw.getSetupAssignments() );
            InitializeViewerState.initBrightness( 0.001, 0.999, bw.getViewerFrameP().getViewerPanel(), bw.getSetupAssignments() );

            // set colors of moving and target images
            bw.getSetupAssignments().getConverterSetups().get( i++ ).setColor( new ARGBType( ARGBType.rgba( 255, 0, 255, 255 ) ) );
            bw.getSetupAssignments().getConverterSetups().get( i ).setColor( new ARGBType( ARGBType.rgba( 0, 255, 0, 255 ) ) );

            // set color of points
            bw.setSpotColor( new Color( 255, 255, 0, 255 ) ); // YELLOW

            bw.getViewerFrameP().setSize( WIDTH, HEIGHT );
            bw.getViewerFrameQ().setSize( WIDTH, HEIGHT );

            bw.getViewerFrameP().setLocation( 0, 0 );
            location = bw.getViewerFrameP().getLocation();

            location.setLocation( location.x + WIDTH, location.y );
            bw.getViewerFrameQ().setLocation( location );

            location.setLocation( location.x + WIDTH, location.y );
            bw.getLandmarkPanel().setLocation( location );

            // repaint
            bw.getViewerFrameP().getViewerPanel().requestRepaint();
            bw.getViewerFrameQ().getViewerPanel().requestRepaint();


            keyProcessor = new KeyEventPostProcessor()
            {

                public boolean postProcessKeyEvent( KeyEvent e )
                {
                    if ( e.getID() == KeyEvent.KEY_PRESSED && e.getKeyCode() == KeyEvent.VK_K )
                    {
                        panel = bw.getViewerFrameQ().getViewerPanel();
                        center = new RealPoint( 3 );
                        panel.displayToGlobalCoordinates( 0.5 * panel.getWidth(), 0.5 * panel.getHeight(), center );
                        x = center.getDoublePosition( 0 );
                        y = center.getDoublePosition( 1 );
                        z = center.getDoublePosition( 2 );
                        panel.displayToGlobalCoordinates( 0.5 * panel.getWidth() + 1, 0.5 * panel.getHeight(), center );
                        dx = x - center.getDoublePosition( 0 );
                        dy = y - center.getDoublePosition( 1 );
                        dz = z - center.getDoublePosition( 2 );

                        d = Math.sqrt( dx * dx + dy * dy + dz * dz );

                        s = Math.log( d ) / Math.log( 2 );

                        x += 133937;
                        y += 63254;
                        z += 22880;
                        z /= 10;

                        x *= 4;
                        y *= 4;
                        z *= 35;

						df = new DecimalFormat( "0.000000" );
						dfshort = new DecimalFormat( "0.0" );
						url = "https://neuropil.janelia.org/tracing/fafb/v9.1/?pid=1&sid0=5&xp=" + df.format( x ) + 
						 "&yp=" + df.format( y ) + 
						 "&zp=" + df.format( z ) + 
						 "&s0=" + dfshort.format( s ) + "&tool=navigator";

                        if ( Desktop.isDesktopSupported() )
                        {
                            desktop = Desktop.getDesktop();
                            try
                            {
                                desktop.browse( new URI( url ) );
                            }
                            catch ( IOException e1 )
                            {
                                e1.printStackTrace();
                            }
                            catch ( URISyntaxException e1 )
                            {
                                e1.printStackTrace();
                            }
                        }
                        else
                        {
                            runtime = Runtime.getRuntime();
                            try
                            {
                                runtime.exec( "xdg-open " + url );
                            }
                            catch ( IOException e1 )
                            {
                                // TODO Auto-generated catch block
                                e1.printStackTrace();
                            }
                        }

                        System.out.println( url );

                    }
                    return true;
                }

            };
			bw.addKeyEventPostProcessor( keyProcessor );

			bw.toggleMovingImageDisplay();
            //bw.restimateTransformation();
            //bw.setIsMovingDisplayTransformed( true );
            bw.getViewerFrameQ().getViewerPanel().setDisplayMode( DisplayMode.FUSED );
            bw.matchOtherViewerPanelToActive();
        }
    }
    catch ( Exception e )
    {
        e.printStackTrace();
    }
}
